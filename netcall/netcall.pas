{  $Id: netcall.pas,v 1.9 2004/01/25 19:38:34 cl Exp $

   This is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version.
  
   The software is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
   General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this software; see the file gpl.txt. If not, write to the
   Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

   Created on July, 21st 2000 by Hinrich Donner <hd@tiro.de>

   This software is part of the OpenXP project (www.openxp.de).
}

{ Abstrakte Klasse TNetcall }

{$I xpdefine.inc}

unit netcall;

interface

uses
  sysutils,
  progressoutput,	{ TProgressOutput }
  objcom,
  timer,
  xpglobal;		{ Nur wegen der Typendefinition }

type
  ENetcall 		= class(Exception);	{ Allgemein (und Vorfahr) }
  ENetcallHangup        = class(ENetcall);
  ENetcallBreak         = class(ENetcall);
  ENetcallTimeout       = class (ENetcall);

const
  { Log chars used in canonical log file. }
  lcCalling = '+';       { 'Calling (dest), (phonenumber)' }
  lcConnect = '=';       { '(connectstring)'/'hangup', generated by (Dis)Connect }
  lcStart = '+';         { 'starting mail transfer' }
  lcFile = '*';          { 'Send/Rcvd (file); (length)b', generated by LogRx/TxFile}
  lcStop = '+';          { 'mail transfer completed/aborted' }
  lcExit = '-';          { 'exiting', generated by Destroy}
  lcError = '%';         { 'carrier lost' }
  lcInfo = ' ';

type
  TNetcall = class
  public
    constructor Create;
    destructor Destroy; override;

  { -- Output ---------------------------------------------------------------- }
  private
    FProgressOutput: TProgressOutput;
    procedure SetProgressOutput(FProgressOutput: TProgressOutput);

  public
    procedure Output(mc: TMsgClass; fmt: string; args: array of const); virtual;
    property ProgressOutput: TProgressOutput read FProgressOutput write SetProgressOutput;

  { -- Logging --------------------------------------------------------------- }
  private
    FLogfile: Text; FLogfileOpened: Boolean;
    FLogfileName: string;
    procedure SLogfileName(const S: String);

  public
    procedure Log(c: Char; const s: String);
    procedure LogRxFile(fn: string);
    procedure LogTxFile(fn: string);
    procedure LogTxRxFile(fn: string; outgoing: boolean);
    property LogfileName: String read FLogfileName write SLogfileName;
  end;

  TCommNetcall = class(TNetcall)
  private
    FCommObj: TCommStream;
    FTimerObj: tpTimer;
    FErrorMsg: string;
    FGotUserBreak: Boolean;

  public
    constructor Create;
    destructor Destroy; override;

    function Connect: boolean; virtual; abstract;
    procedure Disconnect; virtual; abstract;

    { throws ENetcallHangup on no carrier, ENetcallBreak }
    { on user break (and ENetcallTimeout on timeout)     }
    procedure TestBreak;
    procedure TestTimeout;

  protected
    procedure SetCommObj(NewCommObj: TCommStream);
    procedure SetErrorMsg(const NewErrorMsg: string);

    function GetActive: boolean;
    function GetConnected: boolean;

  public
    property GotUserBreak: Boolean read FGotUserBreak;  { true = user break }

    property CommObj: TCommStream read FCommObj write SetCommObj;
    property Timer: TPTimer read FTimerObj;
    property ErrorMsg: string read FErrorMsg write SetErrorMsg;

    property Active: boolean read GetActive;
    property Connected: boolean read GetConnected;
  end;

implementation

uses debug,
  keys,
  fileio;

constructor TNetcall.Create;
begin
  inherited Create;
  ProgressOutput:= nil;
end;

procedure TNetcall.Output(mc: TMsgClass; fmt: string; args: array of const);
var s:string;
begin
  if ProgressOutput<>nil then
    ProgressOutput.WriteFmt(mc,fmt,args);

  case mc of
    mcDefault:  s:='mcDefault';
    mcDebug:    s:='mcDebug';
    mcVerbose:  s:='mcVerbose';
    mcInfo:     s:='mcInfo';
    mcError:    s:='mcError';
    mcFatal:    s:='mcFatal';
    mcPanic:    s:='mcPanic';
  end;

  if fmt<>'' then DebugLog('netcall','Output '+s+': '+Format(fmt,args),dlInform);
end;

destructor TNetcall.Destroy;
begin
  if FLogfileOpened then Close(FLogfile);
  FreeAndNil(FProgressOutput);
end;

procedure TNetcall.SetProgressOutput(FProgressOutput: TProgressOutput);
begin
  FreeAndNil(Self.FProgressOutput);
  Self.FProgressOutput := FProgressOutput;
end;

procedure TNetcall.SLogfileName(const S: String);
var Overwrite: Boolean;
begin
  Overwrite:=Copy(S,1,1)='*';
  if Overwrite then Assign(FLogfile,S)
  else Assign(FLogfile,S);
  if Overwrite or not FileExists(s) then ReWrite(FLogfile)
  else Append(FLogfile);
  FLogfileOpened:=True;
end;
procedure TNetcall.Log(c: Char; const s: String);
begin
  if FLogfileOpened then
    writeln(FLogfile,c,' ',FormatDateTime('hh":"nn":"ss',Now),'  ',s);
  DebugLog('ncmodem','Log: '+c+' '+s,dlInform);
end;

procedure TNetcall.LogTxRxFile(fn: string; outgoing: boolean);
var FileSize,FileHandle: LongInt;
begin
  FileHandle:=FileOpen(fn,fmOpenRead);
  if (FileHandle>0)then begin
    FileSize:=FileSeek(FileHandle,0,fsFromEnd);
    FileClose(FileHandle);
    if outgoing then
      Log(lcFile,'Sent '+ExtractFileName(fn)+', '+IntToStr(FileSize)+'b')
    else
      Log(lcFile,'Rcvd '+ExtractFileName(fn)+', '+IntToStr(FileSize)+'b');
    end;
end;

procedure TNetcall.LogRxFile(fn: string);
begin Self.LogTxRxFile(fn,false) end;

procedure TNetcall.LogTxFile(fn: string);
begin Self.LogTxRxFile(fn,true) end;

constructor TCommNetcall.Create;
begin
  inherited Create;
  FCommObj := nil;
  FTimerObj := new(TPTimer,Init);
end;

destructor TCommNetcall.Destroy;
begin
  FreeAndNil(FCommObj);
  if Assigned(FTimerObj) then dispose(FTimerObj,Done);
  inherited Destroy;
end;

procedure TCommNetcall.TestBreak;
begin
  if not FCommObj.Carrier then
    raise ENetcallHangup.Create('carrier lost');

  if not FGotUserBreak then
    if keypressed and (ReadTaste=keyesc) then begin
      FGotUserBreak:=true;
      Log(lcExit,'User break.');
      Output(mcInfo,'User break - aborting...',[0]);
    end;

  if FGotUserBreak then
    raise ENetcallBreak.Create('user break');
end;

procedure TCommNetcall.TestTimeout;
begin
  if FTimerObj.Timeout then
    raise ENetcallTimeout.Create('timeout');
  TestBreak;
end;

function TCommNetcall.GetActive: boolean;
begin
  result := assigned(FCommObj);
end;

function TCommNetcall.GetConnected: boolean;
begin
  result := assigned(FCommObj) and
    FCommObj.Carrier;
end;

procedure TCommNetcall.SetCommObj(NewCommObj: TCommStream);
begin
  FreeAndNil(FCommObj);
  FCommObj := NewCommObj;
end;

procedure TCommNetcall.SetErrorMsg(const NewErrorMsg: string);
begin
  Output(mcError,'%s',[NewErrorMsg]);
  Log(lcError,NewErrorMsg);
  FErrorMsg := NewErrorMsg;
end;

{
	$Log: netcall.pas,v $
	Revision 1.9  2004/01/25 19:38:34  cl
	- Refactoring of netcall code: moved common methods and properties from
	  TModemNetcall to TNetcall (or intermediate TCommNetcall); proper
	  encapsulation of some objects
	
	Revision 1.8  2002/12/14 22:43:41  dodi
	- fixed some hints and warnings
	
	Revision 1.7  2002/12/06 14:27:31  dodi
	- updated uses, comments and todos
	
	Revision 1.6  2001/10/15 13:12:25  mk
	/bin/bash: ?: command not found
	/bin/bash: q: command not found
	
	Revision 1.5  2001/09/07 23:24:57  ml
	- Kylix compatibility stage II
	
	Revision 1.4  2001/04/16 18:13:28  ma
	- ProgOutWin now pauses a bit on closing
	  (some seconds if an error occured, one second if not)
	- removed other delays
	
	Revision 1.3  2001/03/21 19:17:09  ma
	- using new netcall routines now
	- renamed IPC to Progr.Output
	
	Revision 1.2  2000/07/25 18:02:18  hd
	- NNTP-Unterstuetzung (Anfang)
	
	Revision 1.1  2000/07/25 12:52:24  hd
	- Init
	
}
end.

