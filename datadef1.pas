{ --------------------------------------------------------------- }
{ Dieser Quelltext ist urheberrechtlich geschuetzt.               }
{ (c) 1991-1999 Peter Mandrella                                   }
{ (c) 2000 OpenXP Team & Markus KÑmmerer, http://www.openxp.de    }
{ CrossPoint ist eine eingetragene Marke von Peter Mandrella.     }
{                                                                 }
{ Die Nutzungsbedingungen fuer diesen Quelltext finden Sie in der }
{ Datei SLIZENZ.TXT oder auf www.crosspoint.de/srclicense.html.   }
{ --------------------------------------------------------------- }

{ DATABASE.PAS - lokale Deklarationen }

{$I XPDEFINE.INC }

unit datadef1;

interface

uses dos, typeform,datadef;

const   db_magic  = 'DB1'^Z;
        eb_magic  = 'EB1'^Z;
        ix_magic  = 'IX1'^Z;
        nomagic   = #0#0#0#0;

        rflagDeleted = 1;     { Datensatz-Flag fÅr gelîschten Satz }

        maxifelder= 7;        { maximale Anzahl Felder in einem Ind.-Key }
                              { fÅr mehr ist SchlÅssel-Funktion nîtig    }
        dbdMaxSize= 51;
        maxcache  = 60;       { maximale Index-Cacheseiten }


type    proctype  = procedure;
        magictype = array[0..3] of char;
        barr      = array[0..32767] of byte;
        barrp     = ^barr;

        dbheader  = record
                      magic     : magictype;
                      recs      : longint;   { Anzahl phys. DatensÑtze      }
                      nextinr   : longint;   { nÑchste INT_NR               }
                      firstfree : longint;   { Nr. des ersten freien Satzes }
                      userflags : array[1..8] of word;
                      felder    : word;      { Anzahl Datenfelder           }
                      recsize   : word;      { phys. Record-Grî·e           }
                      hdsize    : word;      { Header-Grî·e in Bytes        }
                      reccount  : longint;   { Anzahl DatensÑtze            }
                      fill      : array[1..22] of byte;
                    end;

        dbfeld    = record               { Feld, physikalisch }
                      name      : dbFeldStr;
                      fill1     : array[1..5] of byte;
                      feldsize  : word;  { physikalisch in Bytes }
                      feldtyp   : byte;
                      nlen,nk   : byte;  { fÅr numerische Werte/Formatierung }
                      fill2     : array[1..11] of byte;
                    end;

        ixheader  = record
                      magic     : magictype;
                      indizes   : word;
                      ixversion : byte;
                      fillbyte  : byte;
                      userflags : array[1..4] of word;
                      hdsize    : word;
                      fill      : array[1..14] of byte;
                    end;

        ixfeld    = record                  { physikalischer Header-Eintrag }
                      feldanz   : byte;     { Anzahl der indizierten Felder }
                      fill1     : byte;     { +$80 -> Index-Funktion        }
                      ifeldnr   : array[1..maxifelder] of word; { +$8000 -> UStr! }
                      nn        : byte;     { SchlÅssel pro Knoten }
                      keysize   : byte;     { SchlÅssellÑnge o. LÑngenbyte }
                      irecsize  : word;     { Knotengrî·e          }
                      firstfree : longint;  { Datei-Offset         }
                      rootrec   : longint;
                      ifunc     : dbIndexFunc;  { intern: Index-Funktion }
                    end;

        ixfeldlist= array[1..1000] of ixfeld;
        ixfp      = ^ixfeldlist;

        { Achtung! Bei énderungen an inodekey/indexnode auch    }
        { entsprechend in DATABASE.ASM und allocnode() Ñndern!! }

        inodekey  = record
                      data    : longint;     { die zugehîrige Satznr.   }
                      ref     : longint;     { Zeiger auf nÑchsten Node }
                      keystr  : string[127]; { der SchlÅssel            }
                    end;
        indexnode = record                  { logischer Index-Knoten   }
                      memsize  : word;      { Grîsse, fÅr FreeMem      }
                      ksize,nk : byte;      { SchlÅsselgrîsse/Anzahl   }
                      irsize   : word;      { Index-Recordgrîsse, "    }
                      db_p     : DB;        { zugehîrige DB, "         }
                      filepos  : longint;
                      anzahl   : integer;   { Anzahl eingetragener SchlÅssel }
                      key      : array[0..4] of inodekey;
                    end;
        inodep    = ^indexnode;

        { Achtung!! énderungen an cachepage auch in DATABASE.ASM Ñndern!! }

        cachepage = record
                      used     : boolean;
                      dbp      : DB;
                      ofs      : longint;
                      lasttick : longint;
                      page     : array[0..264*4+10] of byte;
                    end;
        icache    = array[0..maxcache-1] of cachepage;
        icachep   = ^icache;


        dbdheader = record
                      magic     : magictype;
                      hdsize    : word;
                      userflags : array[1..5] of word;
                      fill1     : array[1..16] of byte;
                      freelist  : array[0..dbdMaxSize] of longint;
                      fill2     : array[1..16] of byte;
                    end;

        dbrec     = record
                      fname     : dbFileName;
                      f1,fi,fe  : file;
                      hd        : dbheader;     { LAN: evtl. kritisch  }
                      hdupdate  : boolean;      { Header immer schreiben }
                      feldp     : dbFLP;        { Feldliste            }
                      recbuf,                   { Record-Buffer        }
                      orecbuf   : barrp;        { original-Inhalt      }
                      ixhd      : ixheader;
                      index     : ixfp;         { Liste der Indizes    }
                      xflag     : boolean;      { externe Datei vorh.  }
                      dbdhd     : dbdheader;
                      flindex   : boolean;      { Datenbank indiziert  }
                      flushed,
                      newrec    : boolean;
                      dEOF,dBOF : boolean;
                      recno     : longint;      { akt. Datensatz, ab 1 }
                      actindex  : word;
                      lastindex : word;         { wird bei dbSeek gesetzt }
                      tiefe     : byte;         { .. zum schrittweisen }
                      vpos      : array[1..20] of longint;   { Bewegen }
                      vx        : array[1..20] of shortint;
                      tempclosed: boolean;
                    end;
        dp        = ^dbrec;


const   lastioerror : integer = 0;
        mustfind    : boolean = true;
        cacheanz    : word    = 0;
        dl          : boolean = false;
        indexver    : byte    = 0;

var     ICP       : dbIndexCProc;     { Index-Kontrollprozedur     }
        found     : boolean;          { Ergebnis der letzten Suche }
        cache     : icachep;
        bb        : byte;             { lokal dbReadN/dbWriteN     }
        dblogfile : text;             { DB-Logfile                 }
        oldexit   : pointer;


function  iohandler:boolean;
procedure error(txt:string);
procedure writeinf(dbp:DB);
procedure writehd(dpb:DB);


implementation

uses database;


function iohandler:boolean;
begin
  lastioerror:=ioresult;
  if lastioerror<>0 then begin
    iohandler:=false;
    writeln('<DB> I/O-Fehler '+strs(lastioerror));
    halt(1);
    end;
  iohandler:=true;
end;


{ interner Fehler }

procedure error(txt:string);
begin
  writeln;
  writeln('<DB> interner Fehler: ',txt);
  if dbInterrProc<>nil then
    proctype(dbInterrProc);
  halt(1);
end;


procedure writeinf(dbp:DB);
begin
  with dp(dbp)^ do
    with hd do
      writeln('Satznr.: ',recno,'   Satzgrî·e: ',recsize,'   SÑtze: ',recs,
              '   Header: ',hdsize,'   Dateigrî·e: ',filesize(f1));
end;


procedure writehd(dpb:DB);
begin
  with dp(dpb)^ do begin
    seek(f1,0);
    blockwrite(f1,hd,sizeof(hd));
    end;
end;


end.

