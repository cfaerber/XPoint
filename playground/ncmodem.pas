{  $Id$

   OpenXP modem netcall base class
   Copyright (C) 2001 OpenXP team (www.openxp.de) and M.Kiesel

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
}

{$I XPDEFINE.INC}

{ OpenXP modem netcall base class }
unit NCModem;

interface

uses
  netcall,timer,objcom,ipcclass;

const
  { Log chars used in canonical log file. }
  lcCalling = '+';       { 'Calling (dest), (phonenumber)' }
  lcConnect = '=';       { '(connectstring)'/'hangup', generated by (Dis)Connect }
  lcStart = '+';         { 'starting mail transfer' }
  lcFile = '*';          { 'Send/Rcvd (file); (length)b', generated by LogRx/TxFile}
  lcStop = '+';          { 'mail transfer completed/aborted' }
  lcExit = '-';          { 'exiting', generated by Destroy}
  lcError = '%';         { 'carrier lost' }
  lcInfo = ' ';

type
  { This is the base class for all netcall types using dialup techniques.
    As ObjCOM provides the communications channel, all comm types ObjCOM
    provides are possible, even communication via IP (useful for example
    for fido over IP). }
  TModemNetcall = class(TNetcall)

  protected
    FCommObj: tpCommObj;
    FTimerObj: tpTimer;
    FConnected,FActive: Boolean;
    FPhonenumbers: String;
    WaitForAnswer,FGotUserBreak: Boolean;
    FLogfile: Text; FLogfileOpened: Boolean;
    FErrorMsg,FLogfileName,FCommInit,ReceivedUpToNow,ModemAnswer: String;

    FPhonenumber: String;
    FLineSpeed: Longint;
    FConnectString: String;

  protected
    procedure SLogfileName(S: String);

    { Creates FCommObj from FCommInit }
    function Activate: Boolean;

    {Process incoming bytes from modem: store in ReceivedUpToNow or move
     all bytes received yet to ModemAnswer and set WaitForAnswer to False
     if WaitForAnswer was True.}
    procedure ProcessIncoming;

    {Process keypresses:
     - set timer to timeout and set FGotUserBreak to True on ESC
     - set timer to timeout on space
     - adjust timer on +/-}
    procedure ProcessKeypresses(AcceptSpace:boolean);

    {Send command to modem. Wait max TimeoutModemAnswer seconds for answer.
     Return answer if received in time; if not received store in
     ReceivedUpToNow, set WaitForAnswer to True and return empty string.}
    function SendCommand(s:string; TimeoutModemAnswer: real): String;

    {Send multiple commands separated by '\\'. Return last modem answer. See
     SendCommand for details.}
    function SendMultCommand(s:string; TimeoutModemAnswer: real): String;

    {Logs a transmitted/received file.}
    procedure LogTxRxFile(fn: string; outgoing: boolean);

  public
    {-------- Variables to initialize for modem dialing -----------------}
    {Phone numbers to dial (separated by spaces). Empty if no dialing required.}
    Phonenumbers: String;
    {Modem init string}
    CommandInit: String;
    {Modem dial prefix string}
    CommandDial: String;
    {Max dial attempts}
    MaxDialAttempts: Integer;
    {Time to wait between dial attempts}
    RedialWaitTime: Integer;
    {Connection establish timeout}
    TimeoutConnectionEstablish: Integer;
    {Modem init timeout}
    TimeoutModemInit: Integer;

    {-------- Variables available after modem dialing -----------------}
    {Phone number connected to}
    property Phonenumber: String read FPhonenumber;
    {Detected line speed (bps)}
    property LineSpeed: Longint read FLineSpeed;
    {Modem string received upon connection}
    property ConnectString: String read FConnectString;

    {------------------------- Properties ----------------------------}
    {Opens log file. Overwrites if first char is '*'.}
    property LogfileName: String read FLogfileName write SLogfileName;

    { True if comm channel initialized }
    property Active: Boolean read FActive;

    property CommObj: TPCommObj read FCommObj;
    property Timer:   TPTimer   read FTimerObj;

    { True if connected to peer }
    property Connected: Boolean read FConnected;
    { Sets/reads timeout (activates on idleing of peer) }
//  property Timeout: Real read FGetTimeout write FSetTimeout;

    { True if interrupted by user }
    property GotUserBreak: Boolean read FGotUserBreak;
    property ErrorMsg: string read FErrorMsg;

    { Create with CommInit string and IPC class }
    constructor CreateWithCommInitAndIPC(const aCommInit: string; aIPC: TIPC);
    { Create with CommObj. Intended for online calls. Active and
      Connected return true after call. }
    constructor CreateWithCommObjAndIPC(p: tpCommObj; aIPC: TIPC);
    { Disconnects if phonenumbers not empty.
      Disposes CommObj.
      Closes log file.
      Disposes IPC. }
    destructor Destroy; override;

    { Connects (= initializes comm channel and dials if necessary) }
    function Connect: boolean; virtual;

    { Logs an event in log file. See lc* log char consts.}
    procedure Log(c: Char; const s: String);
    procedure LogRxFile(fn: string);
    procedure LogTxFile(fn: string);

    { throws ENetcallHangup on no carrier, ENetcallBreak }
    { on user break (and ENetcallTimeout on timeout)     }
    procedure TestBreak;
    procedure TestTimeout;

    { Disconnects. Hangs up if phonenumbers specified. }
    procedure Disconnect; virtual;

  end;

{ Get first phone number in list and rotate list }
function GetNextPhonenumber(var Phonenumbers: string): string;
{ Count phone numbers in list }
function CountPhonenumbers(Phonenumbers: string): integer;

implementation

uses
  {$IFDEF NCRT} xpcurses,{$ELSE}crt,{$ENDIF}
  xpglobal,sysutils,typeform,debug,xpmessagewindow;

{$IFDEF VP}
const fsFromEnd= 2; fsFromCurrent= 1; fsFromBeginning= 0;
{$ENDIF}

function GetNextPhonenumber(var Phonenumbers: string): string;
var p : byte;
begin
  PhoneNumbers:=trim(Phonenumbers);
  p:=Pos(' ',Phonenumbers);
  if p=0 then result:=Phonenumbers
  else begin
    result:=LeftStr(Phonenumbers,p-1);
    Phonenumbers:=trim(mid(Phonenumbers,p))+' '+LeftStr(Phonenumbers,p-1);
  end;
end;

function CountPhonenumbers(Phonenumbers: string): integer;
var n : integer;
begin
  Phonenumbers:=trim(Phonenumbers);
  n:=1;
  while pos(' ',Phonenumbers)>0 do begin
    Phonenumbers:=trim(mid(Phonenumbers,cpos(' ',Phonenumbers)));
    inc(n);
    end;
  result:=n;
end;

constructor TModemNetcall.CreateWithCommInitAndIPC(const aCommInit: string; aIPC: TIPC);
begin
  inherited Create;
  FConnected:=False; FActive:=False; FErrorMsg:=''; IPC:=aIPC; FCommInit:=aCommInit;
  WaitForAnswer:=False; FGotUserBreak:=False; ReceivedUpToNow:=''; ModemAnswer:='';
  Phonenumbers:=''; CommandInit:='ATZ'; CommandDial:='ATD'; MaxDialAttempts:=3;
  TimeoutConnectionEstablish:=90; TimeoutModemInit:=10; RedialWaitTime:=40;
  FLogfileOpened:=False; FPhonenumber:=''; FLineSpeed:=0; FConnectString:='';
  FTimerObj:=new(TPTimer);
end;

constructor TModemNetcall.CreateWithCommObjAndIPC(p: tpCommObj; aIPC: TIPC);
begin
  CreateWithCommInitAndIPC('',aIPC);
  FCommObj:=p; FActive:=True; FConnected:=True;
end;

destructor TModemNetcall.Destroy;
begin
  if FConnected then Disconnect;
  if FActive then begin FCommObj^.Close; Dispose(FCommObj,Done)end;
  if Assigned(FTimerObj) then dispose(FTimerObj);
  Log(lcExit,'exiting');
  if FLogfileOpened then Close(FLogfile);
  inherited destroy;
end;

procedure TModemNetcall.SLogfileName(S: String);
var Overwrite: Boolean;
begin
  Overwrite:=Copy(S,1,1)='*';
  if Overwrite then Delete(S,1,1);
  Assign(FLogfile,S);
  if Overwrite or not FileExists(s) then
    ReWrite(FLogfile)
  else
    Append(FLogfile);
  FLogfileOpened:=True;
end;

function TModemNetcall.Activate: Boolean;
begin
  if not FActive then FActive:=CommInit(FCommInit,FCommObj);
  if not FActive then begin
    FErrorMsg:=ObjCOM.ErrorStr;
    WriteIPC(mcError,'%s',[FErrorMsg]);
    Log(lcError,FErrorMsg);
    end;
  result:=FActive;
end;

procedure TModemNetcall.ProcessIncoming;
var c : char;
begin
  if FCommObj^.CharAvail then begin
    c:=FCommObj^.GetChar;
    if (c=#13) or (c=#10) then begin
      if WaitForAnswer and(ReceivedUpToNow<>'') then begin
        ModemAnswer:=ReceivedUpToNow; ReceivedUpToNow:='';
        DebugLog('ncmodem','Modem answer: "'+ModemAnswer+'"',DLDebug);
        WaitForAnswer:=false;
      end;
    end else if c<>#0 then ReceivedUpToNow:=ReceivedUpToNow+c;
  end else SleepTime(2);
end;

procedure TModemNetcall.ProcessKeypresses(AcceptSpace:boolean);
var c : char;
begin
  if keypressed then begin
    c:=readkey;
    case c of
      #27 : begin
              FTimerObj.SetTimeout(0); WaitForAnswer:=False; ReceivedUpToNow:='';
              DebugLog('ncmodem','User break',DLWarning); FGotUserBreak:=true;
            end;
      '+' : FTimerObj.SetTimeout(FTimerObj.SecsToTimeout+1);
      '-' : if FTimerObj.SecsToTimeout>1 then FTimerObj.SetTimeout(FTimerObj.SecsToTimeout-1);
      ' ' : if AcceptSpace then FTimerObj.SetTimeout(0);
      #0: readkey;
    end;
  end;
end;

function TModemNetcall.SendCommand(s: string; TimeoutModemAnswer: real): String;
var p : byte; EchoTimer: tTimer;
begin
  DebugLog('ncmodem','SendCommand: "'+s+'"',DLDebug);
  FCommObj^.PurgeInBuffer; s:=trim(s);
  if s<>'' then begin {Nicht-leerer Modembefehl; Tilde im Befehl bedeutet ca. 1 Sec Pause}
    repeat
      p:=cpos('~',s);
      if p>0 then begin
        if not FCommObj^.SendString(LeftStr(s,p-1),True)then
          DebugLog('ncmodem','Sending failed, received "'+FCommObj^.ErrorStr+'"',DLWarning);
        delete(s,1,p); SleepTime(1000);
      end;
    until p=0;
    if not FCommObj^.SendString(s+#13,True)then
      DebugLog('ncmodem','Sending failed, received "'+FCommObj^.ErrorStr+'"',DLWarning);
    EchoTimer.Init; EchoTimer.SetTimeout(TimeoutModemAnswer); ReceivedUpToNow:=''; WaitForAnswer:=True;
    repeat
      ProcessIncoming; ProcessKeypresses(false);
    until EchoTimer.Timeout or (not WaitForAnswer); {Warte auf Antwort}
    if EchoTimer.Timeout then ModemAnswer:='';
    SleepTime(200); EchoTimer.Done;
    SendCommand:=ModemAnswer; DebugLog('ncmodem','SendCommand: Got modem answer "'+ModemAnswer+'"',DLDebug);
  end;
end;

function TModemNetcall.SendMultCommand(s: string; TimeoutModemAnswer: real): String;
var p : byte; cmd: String;
begin
  DebugLog('ncmodem','SendMultCommand: "'+s+'"',DLDebug);
  while (length(trim(s))>1) do begin
    p:=pos('\\',s);
    if p=0 then p:=length(s)+1;
    cmd:=trim(LeftStr(s,p-1));
    SendMultCommand:=SendCommand(cmd,TimeoutModemAnswer);
    s:=trim(mid(s,p+2));
    ProcessKeypresses(false);
  end;
end;

function TModemNetcall.Connect: boolean;

  function Bauddetect(ConnectString: String): Longint;
  var p: byte; b: longint;
  begin
    p:=1;
    while(p<=length(ConnectString))and((ConnectString[p]<'0')or(ConnectString[p]>'9'))do inc(p);
    delete(ConnectString,1,p-1);
    p:=1;
    while(p<=length(ConnectString))and(ConnectString[p]>='0')and(ConnectString[p]<='9')do inc(p);
    b:=ival(LeftStr(ConnectString,p-1));
    if(b<300)or(115200 mod b<>0)then Bauddetect:=0 else Bauddetect:=b;
  end;

type tStateDialup= (SDInitialize,SDSendDial,SDWaitForConnect,SDWaitForNextCall,SDModemAnswer,SDConnect,SDNoConnect,SDUserBreak);

var
  StateDialup: tStateDialup;
  iDial: Integer;
  CurrentPhonenumber: String;

begin
  if not FActive then begin
    WriteIPC(mcVerbose,'Opening comm channel',[0]);
    result:=Activate;
    if not result then begin SleepTime(2000); exit end;
    end;
  if Phonenumbers='' then begin
    Log(lcConnect,'CONNECT');
    FConnected:=true; result:=true; exit
    end;
  FGotUserBreak := false;
  DebugLog('ncmodem','Dialup: Numbers "'+Phonenumbers+'", Init "'+CommandInit+'", Dial "'+CommandDial+'", MaxDialAttempts '+
                   Strs(MaxDialAttempts)+', ConnectionTimeout '+Strs(TimeoutConnectionEstablish)+', RedialWait '+Strs(RedialWaitTime),DLInform);
  StateDialup:=SDInitialize; iDial:=0; result:=False;

  while StateDialup<=SDWaitForNextCall do begin
    case StateDialup of
      SDInitialize: begin
                      WriteIPC(mcInfo,'Init modem',[0]);
                      FTimerObj.SetTimeout(TimeoutModemInit);
                      if CommandInit='' then begin
                        FCommObj^.SendString(#13,False); SleepTime(150);
                        FCommObj^.SendString(#13,False); SleepTime(300);
                        SendCommand('AT',1); ProcessKeypresses(false);
                      end;
                      if not FTimerObj.Timeout then begin
                        SendMultCommand(CommandInit,1); StateDialup:=SDSendDial;
                      end;
                    end;
      SDSendDial: begin
                    inc(iDial); FPhonenumber:=GetNextPhonenumber(Phonenumbers);
                    WriteIPC(mcInfo,'Dial %s try %d',[FPhonenumber,iDial]);
                    CurrentPhonenumber:=FPhonenumber;
                    while cpos('-',CurrentPhonenumber)>0 do delete(CurrentPhonenumber,cpos('-',CurrentPhonenumber),1);
                    SendMultCommand(CommandDial+CurrentPhonenumber,1); {Gegenstelle anwaehlen}
                    StateDialup:=SDWaitForConnect;
                  end;
      SDWaitForConnect: begin
                          FTimerObj.SetTimeout(TimeoutConnectionEstablish);
                          TXPMessageWindow(IPC).TimerDisplay:=mwTimeout;
                          TXPMessageWindow(IPC).TimerToUse:=@FTimerObj;
                          repeat
                            ProcessIncoming; ProcessKeypresses(false);
                            WriteIPC(mcVerbose,'',[0]);
                          until FTimerObj.Timeout or(not WaitForAnswer);
                          TXPMessageWindow(IPC).TimerDisplay:=mwElapsedTime;
                          TXPMessageWindow(IPC).TimerToUse:=@TXPMessageWindow(IPC).Timer;
                          result:=False;
                          if not FTimerObj.Timeout then begin
                            {Kein Timeout, kein Userbreak: Vermutlich Connect oder Busy.}
                            WriteIPC(mcInfo,'%s',[ModemAnswer]);
                            SleepTime(200);
                            if LeftStr(ModemAnswer,7)='CARRIER' then ModemAnswer:='CONNECT'+mid(ModemAnswer,8);
                            if LeftStr(ModemAnswer,7)='CONNECT' then begin
                              {Connect!}
                              TXPMessageWindow(IPC).Timer.Start;
                              StateDialup:=SDConnect; result:=True;
                              FConnectString:=ModemAnswer; FConnected:=True;
                              FLineSpeed:=Bauddetect(FConnectString);
                              Log(lcConnect,FConnectString);
                              if not FCommObj^.Carrier then SleepTime(500);  { falls Carrier nach CONNECT kommt }
                              if not FCommObj^.Carrier then SleepTime(1000);
                            end
                          end;
                          if not result then begin {Timeout, Userbreak, Busy oder aehnliches}
                            WriteIPC(mcInfo,'No connect',[0]);
                            FPhonenumber:='';
                            FCommObj^.SendString(#13,False); SleepTime(1000); {ggf. noch auflegen}
                            StateDialup:=SDWaitForNextCall;
                          end;
              end;
      SDWaitForNextCall: begin
                           FTimerObj.SetTimeout(RedialWaitTime);
                           WriteIPC(mcInfo,'Wait for next dial attempt',[0]);
                           if iDial<MaxDialAttempts then begin
                             TXPMessageWindow(IPC).TimerDisplay:=mwTimeout;
                             TXPMessageWindow(IPC).TimerToUse:=@FTimerObj;
                             repeat
                               WriteIPC(mcVerbose,'',[0]);
                               ProcessIncoming; ProcessKeypresses(true);
                               if Pos('RING',ModemAnswer)<>0 then begin
                                 WriteIPC(mcInfo,'Ring detected',[0]);
                                 WaitForAnswer:=True; FTimerObj.SetTimeout(RedialWaitTime);
                               end;
                             until FTimerObj.Timeout;
                             TXPMessageWindow(IPC).TimerDisplay:=mwElapsedTime;
                             TXPMessageWindow(IPC).TimerToUse:=@TXPMessageWindow(IPC).Timer;
                             StateDialup:=SDInitialize;
                           end else StateDialup:=SDNoConnect;
                         end;
    end;
    ProcessKeypresses(true);
    if FGotUserBreak then begin WriteIPC(mcInfo,'Got user break',[0]); exit end;
  end;
end;

procedure TModemNetcall.Log(c: Char; const s: String);
begin
  if FLogfileOpened then
    writeln(FLogfile,c,' ',FormatDateTime('hh":"nn":"ss',Now),'  ',s);
  DebugLog('ncmodem','Log: '+c+' '+s,dlInform);
end;

procedure TModemNetcall.LogTxRxFile(fn: string; outgoing: boolean);
var FileSize,FileHandle: LongInt;
begin
  FileHandle:=FileOpen(fn,fmOpenRead);
  if (FileHandle>0)then begin
    FileSize:=FileSeek(FileHandle,0,fsFromEnd);
    FileClose(FileHandle);
    if outgoing then
      Log(lcFile,'Sent '+ExtractFileName(fn)+', '+IntToStr(FileSize)+'b')
    else
      Log(lcFile,'Rcvd '+ExtractFileName(fn)+', '+IntToStr(FileSize)+'b');
    end;
end;

procedure TModemNetcall.LogRxFile(fn: string);
begin LogTxRxFile(fn,false) end;

procedure TModemNetcall.LogTxFile(fn: string);
begin LogTxRxFile(fn,true) end;

procedure TModemNetcall.Disconnect;
var i : integer;
begin
  if FConnected then Log(lcConnect,'hangup');
  if FPhonenumber<>'' then begin
    WriteIPC(mcInfo,'Hanging up',[0]);
    DebugLog('ncmodem','Hangup',DLInform);
    FCommObj^.PurgeInBuffer; FCommObj^.SetDTR(False);
    SleepTime(500); for i:=1 to 6 do if(not FCommObj^.IgnoreCD)and FCommObj^.Carrier then SleepTime(500);
    FCommObj^.SetDTR(True); SleepTime(500);
    if FCommObj^.ReadyToSend(3)then begin
      FCommObj^.SendString('+++',False);
      for i:=1 to 4 do if((not FCommObj^.IgnoreCD)and FCommObj^.Carrier)then SleepTime(500);
      SleepTime(100);
    end;
    if FCommObj^.ReadyToSend(6)then begin
      FCommObj^.SendString('AT H0'#13,True);
      SleepTime(1000);
      end;
    end;
  FConnected:=False;
end;

{ throws ENetcallHangup on no carrier, ENetcallBreak on user break }
procedure TModemNetcall.TestBreak;
begin
  if not FCommObj^.Carrier then
    raise ENetcallHangup.Create('carrier lost');

  if not FGotUserBreak then
    if keypressed and (readkey=#27) then
    begin
      FGotUserBreak:=true;
      Log(lcExit,'User break.');
      WriteIPC(mcInfo,'User break - aborting...',[0]);
    end;

  if FGotUserBreak then
    raise ENetcallBreak.Create('user break');
end;

procedure TModemNetcall.TestTimeout;
begin
  if FTimerObj.Timeout then
    raise ENetcallTimeout.Create('timeout');
  TestBreak;
end;

end.

{
  $Log$
  Revision 1.21  2001/03/19 12:22:26  cl
  - property Timer:TPTimer ...;
  - procedure TModemNetcall.TestTimer;

  Revision 1.20  2001/03/03 00:25:48  ma
  - small fixes

  Revision 1.19  2001/02/26 12:47:33  cl
  - oops; reverting accidentally committed modifications

  Revision 1.17  2001/02/23 13:57:14  ma
  - fixed small time logging bug

  Revision 1.16  2001/02/23 13:51:05  ma
  - implemented transferred file logging
  - implemented empty send batch (Fido)
  - implemented basic netcall logging

  Revision 1.15  2001/02/19 12:18:28  ma
  - simplified ncmodem usage
  - some small improvements

  Revision 1.14  2001/02/18 16:20:06  ma
  - BinkP's working! :-) - had to cope with some errors in BinkP protocol
    specification...

  Revision 1.13  2001/02/17 21:44:37  ma
  - BinkP protocol provisionally activated by "SetTime" ;-)
  - remote seems not to recognize binkp frames sent yet

  Revision 1.12  2001/02/12 23:43:25  ma
  - some fixes

  Revision 1.11  2001/02/11 16:30:35  ma
  - added sysop call
  - some changes with class constructors

  Revision 1.10  2001/02/11 01:01:10  ma
  - ncmodem does not dial now if no phone number specified
    (removed PerformDial property)
  - added BinkP protocol: Compiles, but not functional yet

  Revision 1.9  2001/02/09 17:31:07  ma
  - added timer to xpmessagewindow
  - did some work on AKA handling in xpncfido

  Revision 1.8  2001/02/06 20:17:50  ma
  - added error handling
  - cleaning up files properly now

  Revision 1.7  2001/02/03 18:40:33  ma
  - added StringLists for tracking sent/rcvd files
  - ncfido using OO ZModem now

  Revision 1.6  2001/02/02 20:59:57  ma
  - moved log routines to ncmodem

  Revision 1.5  2001/02/02 17:14:01  ma
  - new Fidomailer polls :-)

  Revision 1.4  2001/01/28 00:13:58  ma
  - compiles!- untested though.

  Revision 1.3  2001/01/23 11:46:11  ma
  - a little cleanup done

  Revision 1.2  2001/01/10 16:31:26  ma
  - added phone number functions
  - todo: add class communication methods (perhaps in netcall class already)
    because standardized transfer logging should make things *by far* easier
    than they were

  Revision 1.1  2001/01/07 01:15:40  ma
  - perhaps playground concept proves useful

}
